/*

This file was generated by the "C - Kessels engine template.c" template.

*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

#include "engine.h"                 /* The Kessels engine. */
#include "grammar.h"                /* Generated by GOLD. */



#define TRIMREDUCTIONS 1            /* 0=off, 1=on */
int Debug = 1;                      /* 0=off, 1=on */




/* Load input file from disk into memory. */
char *LoadInputFile(char *FileName) {
  FILE *Fin;
  char *InputBuf;
  struct stat statbuf;
  size_t BytesRead;

  /* Sanity check. */
  if ((FileName == NULL) || (*FileName == '\0')) return(NULL);

  /* Open the file. */
  Fin = fopen(FileName,"rb");
  if (Fin == NULL) {
    fprintf(stdout,"Could not open input file:     return(NULL);
    }

  /* Get the size of the file. */
  if (fstat(fileno(Fin),&statbuf) != 0) {
    fprintf(stdout,"Could not stat() the input file:     fclose(Fin);
    return(NULL);
    }

  /* Allocate memory for the input. */
  InputBuf = (char *)malloc(statbuf.st_size + 1);
  if (InputBuf == NULL) {
    fprintf(stdout,"Not enough memory to load the file:     fclose(Fin);
    return(NULL);
    }

  /* Load the file into memory. */
  BytesRead = fread(InputBuf,1,statbuf.st_size,Fin);
  InputBuf[statbuf.st_size] = '\0';

  /* Close the file. */
  fclose(Fin);

  /* Exit if there was an error while reading the file. */
  if (BytesRead != statbuf.st_size) {
    fprintf(stdout,"Error while reading input file:     free(InputBuf);
    return(NULL);
    }

  return(InputBuf);
  }




/* Make a readable copy of a string. All characters outside 32...128 are
   displayed as a HEX number in square brackets, for example "[0A]". */
void ReadableString(char *Input, char *Output, long int Width) {
  char s1[BUFSIZ];

  if (Output == NULL) return;
  while ((Input != NULL) && (*Input != '\0')) {
    if ((*Input >= 32) && ((unsigned char)*Input <= 127)) {
        if (Width > 1) *Output++ = *Input;
      } else {
        if (Width > 4) {
          sprintf(s1,"          *Output++ = '[';
          *Output++ = s1[0];
          *Output++ = s1[1];
          *Output++ = ']';
          }
        }
    Input++;
    }
  *Output = '\0';
  }




void ShowErrorMessage(struct ParseDataStruct *Data, char *Message) {
  struct TokenStruct *Token;
  char s1[BUFSIZ];

  Token = Data->TokenStack;
  if (Token != NULL) Token = Token->NextToken;
  if (Token == NULL) {
    fprintf(stdout,"    return;
    }
  if (Token->Data == NULL) {
    fprintf(stdout,"d column       Token->Column);
    return;
    }
  ReadableString(Token->Data,s1,BUFSIZ);
  fprintf(stdout,"d column s\n",Message,Token->Line,
    Token->Column,s1);
  }




void ShowIndent(int Indent) {
  int i;
  for (i = 0; i < Indent; i++) fprintf(stdout,"  ");
  }




/* Forward declaration of Interpret(); */
char *Interpret(struct TokenStruct *Token, int Debug, int Indent);




/* <Calculations> ::= <Calculate> <Calculations> */
char *Rule_Calculations(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 2 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <Calculations> ::=  */
char *Rule_Calculations2(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 0 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <Calculate> ::= print '(' <Expression> ')' */
char *Rule_Calculate_print_LParen_RParen(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 4 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <Expression> ::= <MultiplyDivide> '+' <Expression> */
char *Rule_Expression_Plus(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 3 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <Expression> ::= <MultiplyDivide> '-' <Expression> */
char *Rule_Expression_Minus(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 3 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <Expression> ::= <MultiplyDivide> */
char *Rule_Expression(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <MultiplyDivide> ::= <Value> '*' <MultiplyDivide> */
char *Rule_MultiplyDivide_Times(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 3 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <MultiplyDivide> ::= <Value> '/' <MultiplyDivide> */
char *Rule_MultiplyDivide_Div(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 3 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <MultiplyDivide> ::= <Value> */
char *Rule_MultiplyDivide(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <Value> ::= DecLiteral */
char *Rule_Value_DecLiteral(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 1 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



/* <Value> ::= '(' <Expression> ')' */
char *Rule_Value_LParen_RParen(struct TokenStruct *Token, int Debug, int Indent) {
  /* Arguments: 3 */
  struct TokenStruct *TokenArg;
  char *Value;

  /* This is just an example of how to fetch the arguments. Usually
     you won't need them all. Remember to free() all the results! */
  TokenArg = Token->Reduction->TokenStack;
  while (TokenArg != NULL) {
    Value = Interpret(TokenArg,Debug,Indent);
    if (Value != NULL) free(Value);
    TokenArg = TokenArg->NextToken;
    }

  /* Return a result. In this example it's always NULL, but it could
     be a real result needed by the rule that is calling. */
  return(NULL);
  };



char *(*RuleJumpTable[])(struct TokenStruct *Token, int Debug, int Indent) = {

  /* 0. <Calculations> ::= <Calculate> <Calculations> */
  Rule_Calculations,

  /* 1. <Calculations> ::=  */
  Rule_Calculations2,

  /* 2. <Calculate> ::= print '(' <Expression> ')' */
  Rule_Calculate_print_LParen_RParen,

  /* 3. <Expression> ::= <MultiplyDivide> '+' <Expression> */
  Rule_Expression_Plus,

  /* 4. <Expression> ::= <MultiplyDivide> '-' <Expression> */
  Rule_Expression_Minus,

  /* 5. <Expression> ::= <MultiplyDivide> */
  Rule_Expression,

  /* 6. <MultiplyDivide> ::= <Value> '*' <MultiplyDivide> */
  Rule_MultiplyDivide_Times,

  /* 7. <MultiplyDivide> ::= <Value> '/' <MultiplyDivide> */
  Rule_MultiplyDivide_Div,

  /* 8. <MultiplyDivide> ::= <Value> */
  Rule_MultiplyDivide,

  /* 9. <Value> ::= DecLiteral */
  Rule_Value_DecLiteral,

  /* 10. <Value> ::= '(' <Expression> ')' */
  Rule_Value_LParen_RParen 
  };




/* Walk through the parsed input script and interpret (execute, evaluate)
   all the statements. This is the heart of the beast and it's executed a
   great many times. You will want to keep it as light as possible.
   Input is a Token on the TokenStack, output is a string. The Token can
   be:
   - A symbol: return the Data of the Token.
   - A reduction (a Rule with all it's arguments): call the Rule's
     function and return it's result.
   */
char *Interpret(struct TokenStruct *Token, int Debug, int Indent) {
  /* Sanity check. */
  if (Token == NULL) return(NULL);

  /* If it's a symbol then return the value. */
  if (Token->Reduction == NULL) {
    if (Debug > 0) {
      ShowIndent(Indent);
      fprintf(stdout,"      }
    return(strdup(Token->Data));
    }

  /* Sanity check. */
  if (Token->Reduction->TokenStack == NULL) return(NULL);

  /* Call the rule and return the result. */
  if (Debug > 0) {
    ShowIndent(Indent);
    fprintf(stdout,"    }
  return(RuleJumpTable[Token->Reduction->Rule](Token,Debug,Indent + 1));
  }





int main(int argc, char *argv[]){
  char *InputBuf;
  struct ParseDataStruct *Data;
  struct TokenStruct *Token;
  short Result;

  /* Load the inputfile into memory. */
  InputBuf = LoadInputFile("Example.input");
  if (InputBuf == NULL) exit(1);

  /* Initialize the parser. */
  Data = ParserInitialize(InputBuf,strlen(InputBuf));

  /* Run the Parser. */
  Result = Parse(Data,TRIMREDUCTIONS,0);

  /* Show a message about the Parser result. */
  switch(Result) {
    case MESSAGEINTERNALERROR:
      fprintf(stdout,"Error: not enough memory to initialize the parser.\n");
      break;
    case MESSAGELEXICALERROR:
      ShowErrorMessage(Data,"Lexical error");
      break;
    case MESSAGECOMMENTERROR:
      ShowErrorMessage(Data,"Comment error");
      break;
    case MESSAGETOKENERROR:
      ShowErrorMessage(Data,"Tokenizer error");
      break;
    case MESSAGESYNTAXERROR:
      ShowErrorMessage(Data,"Syntax error");
      break;
    case MESSAGEACCEPT:
      /* Call the interpreter for all the tokens on the TokenStack. */
      for (Token = Data->TokenStack; Token != NULL; Token = Token->NextToken) {
        if (Debug > 0) fprintf(stdout,"\nStarting to interpret:\n");
        Interpret(Token,Debug,-1);
        }
      break;
    }

  /* Cleanup. */
  ParserCleanup(Data);
  free(InputBuf);
  }
